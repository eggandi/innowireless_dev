/** 
  * @file 
  * @brief KDF2(SHA256) 동작(dot2_KDF2_SHA256())에 대한 단위테스트
  * @date 2022-04-28 
  * @author gyun 
  */


// 라이브러리 헤더 파일
#include "dot2/dot2.h"

// 라이브러리 내부 헤더 파일
#include "dot2-internal.h"
#include "encrypt/dot2-encrypt.h"

// google test 헤더 파일
#include "gtest/gtest.h"
#include "../../test-common-funcs/test-common-funcs.h"
#include "../../test-vectors/test-vectors.h"


/// 테스트벡터 수
#define TEST_VECTOR_NUM (4)
/// 테스트용 Shared secret 최대길이
#define TEST_SS_MAX_LEN (24)
/// 테스트용 Key derivation parameter 최대길이
#define TEST_KDP_MAX_LEN (16)
/// 테스트용 Desired key 최대길이
#define TEST_DESIRED_KEY_MAX_LEN (128)


/**
 * @brief 테스트벡터 구조체
 */
struct TestVector_KDF2_SHA256
{
  uint8_t ss[TEST_SS_MAX_LEN]; ///< Shared secret 바이트열
  size_t ss_len; ///< Shared secret 바이트열 길이
  uint8_t kdp[TEST_KDP_MAX_LEN]; ///< Key derivation parameter 바이트열
  size_t kdp_len; ///< Key derivation parameter 바이트열 길이
  size_t desired_len; ///< 도출할 키의 길이 (바이트단위)
  uint8_t derived_key[TEST_DESIRED_KEY_MAX_LEN]; ///< 도출된 키 바이트열
};


/**
 * @brief 테스트벡터
 *
 * https://stash.campllc.org/projects/SCMS/repos/crypto-test-vectors/browse/kdf.txt
 */
static struct TestVector_KDF2_SHA256 tv[TEST_VECTOR_NUM] = {
  // Test vector #1
  {
    // ss
    { 0x96, 0xC0, 0x56, 0x19, 0xD5, 0x6C, 0x32, 0x8A, 0xB9, 0x5F, 0xE8, 0x4B, 0x18, 0x26, 0x4B, 0x08,
      0x72, 0x5B, 0x85, 0xE3, 0x3F, 0xD3, 0x4F, 0x08
    },
    // ss_len
    24,
    // kdp
    {},
    // kdp_len
    0,
    // desired_len
    16,
    // derived_key
    { 0x44, 0x30, 0x24, 0xc3, 0xda, 0xe6, 0x6b, 0x95, 0xe6, 0xf5, 0x67, 0x06, 0x01, 0x55, 0x8f, 0x71 }
  },
  // Test vector #2
  {
    // ss
    { 0x96, 0xF6, 0x00, 0xB7, 0x3A, 0xD6, 0xAC, 0x56, 0x29, 0x57, 0x7E, 0xCE, 0xD5, 0x17, 0x43, 0xDD,
      0x2C, 0x24, 0xC2, 0x1B, 0x1A, 0xC8, 0x3E, 0xE4
    },
    // ss_len
    24,
    // kdp
    {},
    // kdp_len
    0,
    // desired_len
    16,
    // derived_key
    { 0xb6, 0x29, 0x51, 0x62, 0xa7, 0x80, 0x4f, 0x56, 0x67, 0xba, 0x90, 0x70, 0xf8, 0x2f, 0xa5, 0x22 }
  },
  // Test vector #3
  {
    // ss
    { 0x22, 0x51, 0x8B, 0x10, 0xE7, 0x0F, 0x2A, 0x3F, 0x24, 0x38, 0x10, 0xAE, 0x32, 0x54, 0x13, 0x9E,
      0xFB, 0xEE, 0x04, 0xAA, 0x57, 0xC7, 0xAF, 0x7D
    },
    // ss_len
    24,
    // kdp
    { 0x75, 0xEE, 0xF8, 0x1A, 0xA3, 0x04, 0x1E, 0x33, 0xB8, 0x09, 0x71, 0x20, 0x3D, 0x2C, 0x0C, 0x52 },
    // kdp_len
    16,
    // desired_len
    128,
    // derived_key
    { 0xc4, 0x98, 0xaf, 0x77, 0x16, 0x1c, 0xc5, 0x9f, 0x29, 0x62, 0xb9, 0xa7, 0x13, 0xe2, 0xb2, 0x15,
      0x15, 0x2d, 0x13, 0x97, 0x66, 0xce, 0x34, 0xa7, 0x76, 0xdf, 0x11, 0x86, 0x6a, 0x69, 0xbf, 0x2e,
      0x52, 0xa1, 0x3d, 0x9c, 0x7c, 0x6f, 0xc8, 0x78, 0xc5, 0x0c, 0x5e, 0xa0, 0xbc, 0x7b, 0x00, 0xe0,
      0xda, 0x24, 0x47, 0xcf, 0xd8, 0x74, 0xf6, 0xcf, 0x92, 0xf3, 0x0d, 0x00, 0x97, 0x11, 0x14, 0x85,
      0x50, 0x0c, 0x90, 0xc3, 0xaf, 0x8b, 0x48, 0x78, 0x72, 0xd0, 0x46, 0x85, 0xd1, 0x4c, 0x8d, 0x1d,
      0xc8, 0xd7, 0xfa, 0x08, 0xbe, 0xb0, 0xce, 0x0a, 0xba, 0xbc, 0x11, 0xf0, 0xbd, 0x49, 0x62, 0x69,
      0x14, 0x2d, 0x43, 0x52, 0x5a, 0x78, 0xe5, 0xbc, 0x79, 0xa1, 0x7f, 0x59, 0x67, 0x6a, 0x57, 0x06,
      0xdc, 0x54, 0xd5, 0x4d, 0x4d, 0x1f, 0x0b, 0xd7, 0xe3, 0x86, 0x12, 0x8e, 0xc2, 0x6a, 0xfc, 0x21
    }
  },
  // Test vector #4
  {
    // ss
    { 0x7E, 0x33, 0x5A, 0xFA, 0x4B, 0x31, 0xD7, 0x72, 0xC0, 0x63, 0x5C, 0x7B, 0x0E, 0x06, 0xF2, 0x6F,
      0xCD, 0x78, 0x1D, 0xF9, 0x47, 0xD2, 0x99, 0x0A
    },
    // ss_len
    24,
    // kdp
    { 0xD6, 0x5A, 0x48, 0x12, 0x73, 0x3F, 0x8C, 0xDB, 0xCD, 0xFB, 0x4B, 0x2F, 0x4C, 0x19, 0x1D, 0x87 },
    // kdp_len
    16,
    // desired_len
    128,
    // derived_key
    { 0xc0, 0xbd, 0x9e, 0x38, 0xa8, 0xf9, 0xde, 0x14, 0xc2, 0xac, 0xd3, 0x5b, 0x2f, 0x34, 0x10, 0xc6,
      0x98, 0x8c, 0xf0, 0x24, 0x00, 0x54, 0x36, 0x31, 0xe0, 0xd6, 0xa4, 0xc1, 0xd0, 0x30, 0x36, 0x5a,
      0xcb, 0xf3, 0x98, 0x11, 0x5e, 0x51, 0xaa, 0xdd, 0xeb, 0xdc, 0x95, 0x90, 0x66, 0x42, 0x10, 0xf9,
      0xaa, 0x9f, 0xed, 0x77, 0x0d, 0x4c, 0x57, 0xed, 0xea, 0xfa, 0x0b, 0x8c, 0x14, 0xf9, 0x33, 0x00,
      0x86, 0x52, 0x51, 0x21, 0x8c, 0x26, 0x2d, 0x63, 0xda, 0xdc, 0x47, 0xdf, 0xa0, 0xe0, 0x28, 0x48,
      0x26, 0x79, 0x39, 0x85, 0x13, 0x7e, 0x0a, 0x54, 0x4e, 0xc8, 0x0a, 0xbf, 0x2f, 0xdf, 0x5a, 0xb9,
      0x0b, 0xda, 0xea, 0x66, 0x20, 0x40, 0x12, 0xef, 0xe3, 0x49, 0x71, 0xdc, 0x43, 0x1d, 0x62, 0x5c,
      0xd9, 0xa3, 0x29, 0xb8, 0x21, 0x7c, 0xc8, 0xfd, 0x0d, 0x9f, 0x02, 0xb1, 0x3f, 0x2f, 0x6b, 0x0b
    }
  }
};


/**
 * @brief KDF2 함수가 정상적으로 키 스트림을 도출하는 것을 확인한다.
 */
TEST(KDF2_SHA256, NORMAL)
{
  ASSERT_EQ(Dot2_Init(kDot2LogLevel_Err, kDot2SigningParamsPrecomputeInterval_Default, "/dev/urandom", kDot2LeapSeconds_Default), kDot2Result_Success);

  uint8_t *key_stream;
  for (int i = 0; i < TEST_VECTOR_NUM; i++) {
    key_stream = dot2_KDF2_SHA256(tv[i].ss, tv[i].ss_len, tv[i].kdp, tv[i].kdp_len, tv[i].desired_len);
    ASSERT_TRUE(key_stream != nullptr);
    ASSERT_TRUE(0 == memcmp(key_stream, tv[i].derived_key, tv[i].desired_len));
    free(key_stream);
  }

  Dot2_Release();
}
