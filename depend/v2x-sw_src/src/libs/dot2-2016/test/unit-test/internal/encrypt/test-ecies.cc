/** 
  * @file 
  * @brief ECIES 동작(dot2_ECIES_Encrypt())에 대한 단위테스트
  * @date 2022-04-28 
  * @author gyun 
  */


#include "gtest/gtest.h"

// 라이브러리 헤더 파일
#include "dot2/dot2.h"

// 라이브러리 내부 헤더 파일
#include "dot2-internal.h"
#include "encrypt/dot2-encrypt.h"


/// 테스트벡터 수
#define ECIES_TEST_VECTOR_NUM (4)


/**
 * @brief 테스트벡터 구조체
 */
struct TestVector_ECIES
{
  uint8_t v[DOT2_EC_256_KEY_LEN]; ///< 송신자의 ephemeral 개인키 (ECIES 암호화 입력)
  uint8_t k[DOT2_AES_128_LEN]; ///< 암호화될 AES 키 (ECIES 암호화 입력)
  uint8_t P1[DOT2_SHA_256_LEN]; ///< 수신자정보에 대한 해시값 (ECIES 암호화 입력)
  uint8_t r[DOT2_EC_256_KEY_LEN]; ///< 수신자의 개인키 (ECIES 복호화 입력)
  uint8_t R[DOT2_EC_256_PUB_KEY_LEN]; ///< 수신자의 공개키 (ECIES 암호화 입력)
  uint8_t V[DOT2_EC_256_PUB_KEY_LEN]; ///< 송신자의 ephemeral 공개키 (ECIES 복호화 입력)
  uint8_t C[DOT2_AES_128_LEN]; ///< 암호화된 AES 공개키 (ECIES 암호화 출력, 복호화 입력)
  uint8_t T[DOT2_AUTH_TAG_LEN]; ///< Authentication tag (ECIES 암호화 출력, 복호화 입력)
};


/**
 * @brief 테스트벡터
 *
 * https://stash.campllc.org/projects/SCMS/repos/crypto-test-vectors/browse/ecies.txt
 */
static struct TestVector_ECIES tv[ECIES_TEST_VECTOR_NUM] = {
  // Test vector #1
  {
    // v
    { 0x13, 0x84, 0xC3, 0x1D, 0x69, 0x82, 0xD5, 0x2B, 0xCA, 0x3B, 0xED, 0x8A, 0x7E, 0x60, 0xF5, 0x2F,
      0xEC, 0xDA, 0xB4, 0x4E, 0x5C, 0x0E, 0xA1, 0x66, 0x81, 0x5A, 0x81, 0x59, 0xE0, 0x9F, 0xFB, 0x42 },
    // k
    { 0x91, 0x69, 0x15, 0x5B, 0x08, 0xB0, 0x76, 0x74, 0xCB, 0xAD, 0xF7, 0x5F, 0xB4, 0x6A, 0x7B, 0x0D },
    // P1
    { 0xA6, 0xB7, 0xB5, 0x25, 0x54, 0xB4, 0x20, 0x3F, 0x7E, 0x3A, 0xCF, 0xDB, 0x3A, 0x3E, 0xD8, 0x67,
      0x4E, 0xE0, 0x86, 0xCE, 0x59, 0x06, 0xA7, 0xCA, 0xC2, 0xF8, 0xA3, 0x98, 0x30, 0x6D, 0x3B, 0xE9 },
    // r
    { 0x06, 0x0E, 0x41, 0x44, 0x0A, 0x4E, 0x35, 0x15, 0x4C, 0xA0, 0xEF, 0xCB, 0x52, 0x41, 0x21, 0x45,
      0x83, 0x6A, 0xD0, 0x32, 0x83, 0x3E, 0x6B, 0xC7, 0x81, 0xE5, 0x33, 0xBF, 0x14, 0x85, 0x10, 0x85 },
    // R
    { 0x04, // Uncompressed form
      0x8C, 0x5E, 0x20, 0xFE, 0x31, 0x93, 0x5F, 0x6F, 0xA6, 0x82, 0xA1, 0xF6, 0xD4, 0x6E, 0x44, 0x68,
      0x53, 0x4F, 0xFE, 0xA1, 0xA6, 0x98, 0xB1, 0x4B, 0x0B, 0x12, 0x51, 0x3E, 0xED, 0x8D, 0xEB, 0x11,
      0x12, 0x70, 0xFE, 0xC2, 0x42, 0x7E, 0x6A, 0x15, 0x4D, 0xFC, 0xAE, 0x33, 0x68, 0x58, 0x43, 0x96,
      0xC8, 0x25, 0x1A, 0x04, 0xE2, 0xAE, 0x7D, 0x87, 0xB0, 0x16, 0xFF, 0x65, 0xD2, 0x2D, 0x6F, 0x9E },
    // V
    { 0x04, // Uncompressed form
      0xF4, 0x5A, 0x99, 0x13, 0x7B, 0x1B, 0xB2, 0xC1, 0x50, 0xD6, 0xD8, 0xCF, 0x72, 0x92, 0xCA, 0x07,
      0xDA, 0x68, 0xC0, 0x03, 0xDA, 0xA7, 0x66, 0xA9, 0xAF, 0x7F, 0x67, 0xF5, 0xEE, 0x91, 0x68, 0x28,
      0xF6, 0xA2, 0x52, 0x16, 0xF4, 0x4C, 0xB6, 0x4A, 0x96, 0xC2, 0x29, 0xAE, 0x00, 0xB4, 0x79, 0x85,
      0x7B, 0x3B, 0x81, 0xC1, 0x31, 0x9F, 0xB2, 0xAD, 0xF0, 0xE8, 0xDB, 0x26, 0x81, 0x76, 0x97, 0x29 },
    // C
    { 0xA6, 0x34, 0x20, 0x13, 0xD6, 0x23, 0xAD, 0x6C, 0x5F, 0x68, 0x82, 0x46, 0x96, 0x73, 0xAE, 0x33 },
    // T
    { 0x80, 0xE1, 0xD8, 0x5D, 0x30, 0xF1, 0xBA, 0xE4, 0xEC, 0xF1, 0xA5, 0x34, 0xA8, 0x9A, 0x07, 0x86 }
  },
  // Test vector #2
  {
    // v
    { 0xD4, 0x18, 0x76, 0x0F, 0x0C, 0xB2, 0xDC, 0xB8, 0x56, 0xBC, 0x3C, 0x72, 0x17, 0xAD, 0x3A, 0xA3,
      0x6D, 0xB6, 0x74, 0x2A, 0xE1, 0xDB, 0x65, 0x5A, 0x3D, 0x28, 0xDF, 0x88, 0xCB, 0xBF, 0x84, 0xE1 },
    // k
    { 0x91, 0x69, 0x15, 0x5B, 0x08, 0xB0, 0x76, 0x74, 0xCB, 0xAD, 0xF7, 0x5F, 0xB4, 0x6A, 0x7B, 0x0D },
    // P1
    { 0xA6, 0xB7, 0xB5, 0x25, 0x54, 0xB4, 0x20, 0x3F, 0x7E, 0x3A, 0xCF, 0xDB, 0x3A, 0x3E, 0xD8, 0x67,
      0x4E, 0xE0, 0x86, 0xCE, 0x59, 0x06, 0xA7, 0xCA, 0xC2, 0xF8, 0xA3, 0x98, 0x30, 0x6D, 0x3B, 0xE9 },
    // r
    { 0x06, 0x0E, 0x41, 0x44, 0x0A, 0x4E, 0x35, 0x15, 0x4C, 0xA0, 0xEF, 0xCB, 0x52, 0x41, 0x21, 0x45,
      0x83, 0x6A, 0xD0, 0x32, 0x83, 0x3E, 0x6B, 0xC7, 0x81, 0xE5, 0x33, 0xBF, 0x14, 0x85, 0x10, 0x85 },
    // R
    { 0x04, // Uncompressed form
      0x8C, 0x5E, 0x20, 0xFE, 0x31, 0x93, 0x5F, 0x6F, 0xA6, 0x82, 0xA1, 0xF6, 0xD4, 0x6E, 0x44, 0x68,
      0x53, 0x4F, 0xFE, 0xA1, 0xA6, 0x98, 0xB1, 0x4B, 0x0B, 0x12, 0x51, 0x3E, 0xED, 0x8D, 0xEB, 0x11,
      0x12, 0x70, 0xFE, 0xC2, 0x42, 0x7E, 0x6A, 0x15, 0x4D, 0xFC, 0xAE, 0x33, 0x68, 0x58, 0x43, 0x96,
      0xC8, 0x25, 0x1A, 0x04, 0xE2, 0xAE, 0x7D, 0x87, 0xB0, 0x16, 0xFF, 0x65, 0xD2, 0x2D, 0x6F, 0x9E },
    // V
    { 0x04, // Uncompressed form
      0xEE, 0x9C, 0xC7, 0xFB, 0xD9, 0xED, 0xEC, 0xEA, 0x41, 0xF7, 0xC8, 0xBD, 0x25, 0x8E, 0x8D, 0x2E,
      0x98, 0x8E, 0x75, 0xBD, 0x06, 0x9A, 0xDD, 0xCA, 0x1E, 0x5A, 0x38, 0xE5, 0x34, 0xAC, 0x68, 0x18,
      0x5A, 0xE3, 0xC8, 0xD9, 0xFE, 0x0B, 0x1F, 0xC7, 0x43, 0x8F, 0x29, 0x41, 0x7C, 0x24, 0x0F, 0x8B,
      0xF8, 0x1C, 0x35, 0x8E, 0xC1, 0xA4, 0xD0, 0xC6, 0xE9, 0x8D, 0x8E, 0xDB, 0xCC, 0x71, 0x40, 0x17 },
    // C
    { 0xDD, 0x53, 0x0B, 0xE3, 0xBC, 0xD1, 0x49, 0xE8, 0x81, 0xE0, 0x9F, 0x06, 0xE1, 0x60, 0xF5, 0xA0 },
    // T
    { 0x06, 0xC1, 0xF0, 0xF5, 0xEA, 0xED, 0x45, 0x3C, 0xAF, 0x78, 0xE0, 0x1A, 0x3D, 0x16, 0xA0, 0x01 }
  },
  // Test vector #3
  {
    // v
    { 0x13, 0x84, 0xC3, 0x1D, 0x69, 0x82, 0xD5, 0x2B, 0xCA, 0x3B, 0xED, 0x8A, 0x7E, 0x60, 0xF5, 0x2F,
      0xEC, 0xDA, 0xB4, 0x4E, 0x5C, 0x0E, 0xA1, 0x66, 0x81, 0x5A, 0x81, 0x59, 0xE0, 0x9F, 0xFB, 0x42 },
    // k
    { 0x68, 0x7E, 0x97, 0x57, 0xDE, 0xBF, 0xD8, 0x7B, 0x0C, 0x26, 0x73, 0x30, 0xC1, 0x83, 0xC7, 0xB6 },
    // P1
    { 0x05, 0xBE, 0xD5, 0xF8, 0x67, 0xB8, 0x9F, 0x30, 0xFE, 0x55, 0x52, 0xDF, 0x41, 0x4B, 0x65, 0xB9,
      0xDD, 0x40, 0x73, 0xFC, 0x38, 0x5D, 0x14, 0x92, 0x1C, 0x64, 0x1A, 0x14, 0x5A, 0xA1, 0x20, 0x51 },
    // r
    { 0xDA, 0x5E, 0x1D, 0x85, 0x3F, 0xCC, 0x5D, 0x0C, 0x16, 0x2A, 0x24, 0x5B, 0x9F, 0x29, 0xD3, 0x8E,
      0xB6, 0x05, 0x9F, 0x0D, 0xB1, 0x72, 0xFB, 0x7F, 0xDA, 0x66, 0x63, 0xB9, 0x25, 0xE8, 0xC7, 0x44 },
    // R
    { 0x04, // Uncompressed form
      0x80, 0x08, 0xB0, 0x6F, 0xC4, 0xC9, 0xF9, 0x85, 0x60, 0x48, 0xDA, 0x18, 0x6E, 0x7D, 0xC3, 0x90,
      0x96, 0x3D, 0x6A, 0x42, 0x4E, 0x80, 0xB2, 0x74, 0xFB, 0x75, 0xD1, 0x21, 0x88, 0xD7, 0xD7, 0x3F,
      0x27, 0x74, 0xFB, 0x96, 0x00, 0xF2, 0x7D, 0x7B, 0x3B, 0xBB, 0x2F, 0x7F, 0xCD, 0x8D, 0x2C, 0x96,
      0xD4, 0x61, 0x9E, 0xF9, 0xB4, 0x69, 0x2C, 0x6A, 0x7C, 0x57, 0x33, 0xB5, 0xBA, 0xC8, 0xB2, 0x7D },
    // V
    { 0x04, // Uncompressed form
      0xF4, 0x5A, 0x99, 0x13, 0x7B, 0x1B, 0xB2, 0xC1, 0x50, 0xD6, 0xD8, 0xCF, 0x72, 0x92, 0xCA, 0x07,
      0xDA, 0x68, 0xC0, 0x03, 0xDA, 0xA7, 0x66, 0xA9, 0xAF, 0x7F, 0x67, 0xF5, 0xEE, 0x91, 0x68, 0x28,
      0xF6, 0xA2, 0x52, 0x16, 0xF4, 0x4C, 0xB6, 0x4A, 0x96, 0xC2, 0x29, 0xAE, 0x00, 0xB4, 0x79, 0x85,
      0x7B, 0x3B, 0x81, 0xC1, 0x31, 0x9F, 0xB2, 0xAD, 0xF0, 0xE8, 0xDB, 0x26, 0x81, 0x76, 0x97, 0x29 },
    // C
    { 0x1F, 0x63, 0x46, 0xED, 0xAE, 0xAF, 0x57, 0x56, 0x1F, 0xC9, 0x60, 0x4F, 0xEB, 0xEF, 0xF4, 0x4E },
    // T
    { 0x37, 0x3C, 0x0F, 0xA7, 0xC5, 0x2A, 0x07, 0x98, 0xEC, 0x36, 0xEA, 0xDF, 0xE3, 0x87, 0xC3, 0xEF }
  },
  // Test vector #4
  {
    // v
    { 0x46, 0x24, 0xA6, 0xF9, 0xF6, 0xBC, 0x6B, 0xD0, 0x88, 0xA7, 0x1E, 0xD9, 0x7B, 0x3A, 0xEE, 0x98,
      0x3B, 0x5C, 0xC2, 0xF5, 0x74, 0xF6, 0x4E, 0x96, 0xA5, 0x31, 0xD2, 0x46, 0x41, 0x37, 0x04, 0x9F },
    // k
    { 0x68, 0x7E, 0x97, 0x57, 0xDE, 0xBF, 0xD8, 0x7B, 0x0C, 0x26, 0x73, 0x30, 0xC1, 0x83, 0xC7, 0xB6 },
    // P1
    { 0x05, 0xBE, 0xD5, 0xF8, 0x67, 0xB8, 0x9F, 0x30, 0xFE, 0x55, 0x52, 0xDF, 0x41, 0x4B, 0x65, 0xB9,
      0xDD, 0x40, 0x73, 0xFC, 0x38, 0x5D, 0x14, 0x92, 0x1C, 0x64, 0x1A, 0x14, 0x5A, 0xA1, 0x20, 0x51 },
    // r
    { 0xDA, 0x5E, 0x1D, 0x85, 0x3F, 0xCC, 0x5D, 0x0C, 0x16, 0x2A, 0x24, 0x5B, 0x9F, 0x29, 0xD3, 0x8E,
      0xB6, 0x05, 0x9F, 0x0D, 0xB1, 0x72, 0xFB, 0x7F, 0xDA, 0x66, 0x63, 0xB9, 0x25, 0xE8, 0xC7, 0x44 },
    // R
    { 0x04, // Uncompressed form
      0x80, 0x08, 0xB0, 0x6F, 0xC4, 0xC9, 0xF9, 0x85, 0x60, 0x48, 0xDA, 0x18, 0x6E, 0x7D, 0xC3, 0x90,
      0x96, 0x3D, 0x6A, 0x42, 0x4E, 0x80, 0xB2, 0x74, 0xFB, 0x75, 0xD1, 0x21, 0x88, 0xD7, 0xD7, 0x3F,
      0x27, 0x74, 0xFB, 0x96, 0x00, 0xF2, 0x7D, 0x7B, 0x3B, 0xBB, 0x2F, 0x7F, 0xCD, 0x8D, 0x2C, 0x96,
      0xD4, 0x61, 0x9E, 0xF9, 0xB4, 0x69, 0x2C, 0x6A, 0x7C, 0x57, 0x33, 0xB5, 0xBA, 0xC8, 0xB2, 0x7D },
    // V
    { 0x04, // Uncompressed form
      0x12, 0x1A, 0xA4, 0x95, 0xC6, 0xB2, 0xC0, 0x7A, 0x2B, 0x2D, 0xAE, 0xC3, 0x6B, 0xD2, 0x07, 0xD6,
      0x62, 0x0D, 0x7E, 0x60, 0x81, 0x05, 0x0D, 0xF5, 0xDE, 0x3E, 0x96, 0x96, 0x86, 0x8F, 0xCD, 0xCA,
      0x46, 0xC3, 0x1A, 0x1A, 0xBE, 0xA0, 0xBD, 0xDA, 0xAA, 0xAE, 0xFB, 0xBA, 0x3A, 0xFD, 0xBF, 0xF1,
      0xAC, 0x8D, 0x19, 0x6B, 0xC3, 0x13, 0xFC, 0x13, 0x09, 0x26, 0x81, 0x0C, 0x05, 0x50, 0x39, 0x50 },
    // C
    { 0x6C, 0xFD, 0x13, 0xB7, 0x64, 0x36, 0xCD, 0x0D, 0xB7, 0x02, 0x44, 0xFA, 0xE3, 0x80, 0xCB, 0xA1 },
    // T
    { 0xC8, 0xBF, 0x18, 0xAC, 0x79, 0x6B, 0x0B, 0x1D, 0x3A, 0x12, 0x56, 0xD3, 0xA9, 0x16, 0x76, 0xC8 }
  }
};


/**
 * @brief ECIES 함수가 정상적으로 AES 키를 암호화하는 것을 확인한다.
 */
TEST(ECIES, ENCRYPT)
{
  ASSERT_EQ(Dot2_Init(kDot2LogLevel_Err, kDot2SigningParamsPrecomputeInterval_Default, "/dev/urandom", kDot2LeapSeconds_Default), kDot2Result_Success);

  struct Dot2ECPrivateKey v{}; // 송신자 임시개인키
  struct Dot2AESKey k{}; // 암호화될 AES 키
  struct Dot2ECPublicKey R{}; // 상대방 공개키
  struct Dot2AESKey C{}; // 암호화된 AES 키
  struct Dot2AESAuthTag T{}; // Authentication tag
  struct Dot2SHA256 P1{}; // 키생성함수 입력 해시
  for (int i = 0; i < ECIES_TEST_VECTOR_NUM; i++) {
    memcpy(v.octs, tv[i].v, sizeof(v.octs));
    memcpy(k.octs, tv[i].k, sizeof(k.octs));
    memcpy(R.u.octs, tv[i].R, sizeof(R.u.octs));
    memcpy(P1.octs, tv[i].P1, sizeof(P1.octs));
    ASSERT_EQ(dot2_ECIES_Encrypt(&v, &k, &P1, &R, &C, &T), kDot2Result_Success);
    ASSERT_TRUE(0 == memcmp(C.octs, tv[i].C, sizeof(C.octs)));
    ASSERT_TRUE(0 == memcmp(T.octs, tv[i].T, sizeof(T.octs)));
  }

  Dot2_Release();
}


/**
 * @brief ECIES 함수가 정상적으로 AES 키를 복호화하는 것을 확인한다.
 */
TEST(ECIES, DECRYPT)
{
  ASSERT_EQ(Dot2_Init(kDot2LogLevel_Err, kDot2SigningParamsPrecomputeInterval_Default, "/dev/urandom", kDot2LeapSeconds_Default), kDot2Result_Success);

  struct Dot2ECPublicKey V{}; // 송신자 임시공개키
  struct Dot2AESKey C{}; // 암호화된 AES 키
  struct Dot2AESAuthTag T{}; // Authentication tag
  struct Dot2ECPrivateKey r{}; // 수신자 개인키
  struct Dot2AESKey k{}; // 복호화된 AES 키
  struct Dot2SHA256 P1{}; // 키생성함수 입력 해시
  for (int i = 0; i < ECIES_TEST_VECTOR_NUM; i++) {
    memcpy(V.u.octs, tv[i].V, sizeof(V.u.octs));
    memcpy(C.octs, tv[i].C, sizeof(C.octs));
    memcpy(T.octs, tv[i].T, sizeof(T.octs));
    memcpy(r.octs, tv[i].r, sizeof(r.octs));
    memcpy(P1.octs, tv[i].P1, sizeof(P1.octs));
    ASSERT_EQ(dot2_ECIES_Decrypt(&V, &C, &T, &r, &P1, &k), kDot2Result_Success);
    ASSERT_TRUE(0 == memcmp(k.octs, tv[i].k, sizeof(k)));
  }

  Dot2_Release();
}
